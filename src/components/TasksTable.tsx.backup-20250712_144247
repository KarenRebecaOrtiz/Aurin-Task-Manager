'use client';

import { useEffect, useRef, useMemo, useCallback, memo } from 'react';
import { useUser } from '@clerk/nextjs';
import Image from 'next/image';
import { gsap } from 'gsap';
import { motion, AnimatePresence } from 'framer-motion';
import { collection, onSnapshot, query } from 'firebase/firestore';
import { db } from '@/lib/firebase';
import Table from './Table';
import ActionMenu from './ui/ActionMenu';
import styles from './TasksTable.module.scss';
import UserSwiper from '@/components/UserSwiper';
import { useAuth } from '@/contexts/AuthContext';
import SkeletonLoader from '@/components/SkeletonLoader';
import { getLastActivityTimestamp, archiveTask } from '@/lib/taskUtils';
import { useTaskNotifications } from '@/hooks/useTaskNotifications';
import NotificationDot from '@/components/ui/NotificationDot';
import { useStore } from 'zustand';
import { useShallow } from 'zustand/react/shallow';
import { tasksTableStore } from '@/stores/tasksTableStore';

interface Client {
  id: string;
  name: string;
  imageUrl: string;
}

interface User {
  id: string;
  imageUrl: string;
  fullName: string;
  role: string;
}

interface Task {
  id: string;
  clientId: string;
  project: string;
  name: string;
  description: string;
  status: string;
  priority: string;
  startDate: string | null;
  endDate: string | null;
  LeadedBy: string[];
  AssignedTo: string[];
  createdAt: string;
  CreatedBy?: string;
  lastActivity?: string;
  hasUnreadUpdates?: boolean;
  lastViewedBy?: { [userId: string]: string };
  archived?: boolean;
  archivedAt?: string;
  archivedBy?: string;
}

type TaskView = 'table' | 'kanban';

// Helper function to normalize status values (same as TasksKanban)
const normalizeStatus = (status: string): string => {
  if (!status) return 'Por Iniciar';
  
  const normalized = status.trim();
  
  const statusMap: { [key: string]: string } = {
    'por iniciar': 'Por Iniciar',
    'por-iniciar': 'Por Iniciar',
    'pendiente': 'Por Iniciar',
    'pending': 'Por Iniciar',
    'to do': 'Por Iniciar',
    'todo': 'Por Iniciar',
    'en proceso': 'En Proceso',
    'en-proceso': 'En Proceso',
    'in progress': 'En Proceso',
    'progreso': 'En Proceso',
    'por finalizar': 'Por Finalizar',
    'por-finalizar': 'Por Finalizar',
    'to finish': 'Por Finalizar',
    'finalizado': 'Finalizado',
    'finalizada': 'Finalizado',
    'completed': 'Finalizado',
    'completado': 'Finalizado',
    'completada': 'Finalizado',
    'done': 'Finalizado',
    'terminado': 'Finalizado',
    'terminada': 'Finalizado',
    'finished': 'Finalizado',
    'backlog': 'Backlog',
    'cancelado': 'Cancelado',
    'cancelada': 'Cancelado',
    'cancelled': 'Cancelado',
    'diseno': 'Por Iniciar',
    'diseño': 'Por Iniciar',
    'design': 'Por Iniciar',
    'desarrollo': 'En Proceso',
    'development': 'En Proceso',
    'dev': 'En Proceso',
  };
  
  return statusMap[normalized.toLowerCase()] || normalized;
};

interface AvatarGroupProps {
  assignedUserIds: string[];
  leadedByUserIds: string[];
  users: User[];
  currentUserId: string;
}

const AvatarGroup: React.FC<AvatarGroupProps> = ({ assignedUserIds, leadedByUserIds, users, currentUserId }) => {
  const avatars = useMemo(() => {
    if (!Array.isArray(users)) {
      console.warn('[AvatarGroup] Users prop is not an array:', users);
      return [];
    }
    const matchedUsers = users.filter((user) => assignedUserIds.includes(user.id) || leadedByUserIds.includes(user.id)).slice(0, 5);
    return matchedUsers.sort((a, b) => {
      if (a.id === currentUserId) return -1;
      if (b.id === currentUserId) return 1;
      return 0;
    });
  }, [assignedUserIds, leadedByUserIds, users, currentUserId]);

  return (
    <div className={styles.avatarGroup}>
      {avatars.length > 0 ? 
        avatars.map((user) => (
          <div key={user.id} className={styles.avatar}>
            <span className={styles.avatarName}>{user.fullName}</span>
            <Image
              src={user.imageUrl || '/empty-image.png'}
              alt={`${user.fullName}'s avatar`}
              width={40}
              height={40}
              className={styles.avatarImage}
              onError={(e) => {
                e.currentTarget.src = '/empty-image.png';
              }}
            />
          </div>
        ))
        : <span>No asignados</span>
      }
    </div>
  );
};

interface TasksTableProps {
  onNewTaskOpen: () => void;
  onEditTaskOpen: (taskId: string) => void;
  onChatSidebarOpen: (task: Task) => void;
  onMessageSidebarOpen: (user: User) => void;
  onOpenProfile: (user: { id: string; imageUrl: string }) => void;
  onViewChange: (view: TaskView) => void;
  onDeleteTaskOpen: (taskId: string) => void;
  onArchiveTableOpen: () => void;
  externalTasks?: Task[];
  externalClients?: Client[];
  externalUsers?: User[];
}

const TasksTable = memo(({
  onNewTaskOpen,
  onEditTaskOpen,
  onChatSidebarOpen,
  onMessageSidebarOpen,
  onOpenProfile,
  onViewChange,
  onDeleteTaskOpen,
  onArchiveTableOpen,
  externalTasks,
  externalClients,
  externalUsers,
}: TasksTableProps) => {
  const { user } = useUser();
  const { isAdmin } = useAuth();
  const userId = useMemo(() => user?.id || '', [user]);
  const { getUnreadCount, markAsViewed } = useTaskNotifications();

  // Refs
  const userDropdownRef = useRef<HTMLDivElement>(null);
  const undoTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const priorityDropdownRef = useRef<HTMLDivElement>(null);
  const clientDropdownRef = useRef<HTMLDivElement>(null);
  const actionButtonRefs = useRef<Map<string, HTMLButtonElement>>(new Map());
  const actionMenuRef = useRef<HTMLDivElement>(null);
  const effectiveTasksRef = useRef<Task[]>([]);
  const effectiveTasksIdsRef = useRef<string>('');

  // Memoized data
  const effectiveTasks = useMemo(() => {
    console.log('[TasksTableRenders] Tasks memo', { externalTasksLength: externalTasks?.length });
    return externalTasks ?? [];
  }, [externalTasks]);

  const effectiveClients = useMemo(() => {
    console.log('[TasksTableRenders] Clients memo', { externalClientsLength: externalClients?.length });
    return externalClients ?? [];
  }, [externalClients]);

  const effectiveUsers = useMemo(() => {
    console.log('[TasksTableRenders] Users memo', { externalUsersLength: externalUsers?.length });
    return externalUsers ?? [];
  }, [externalUsers]);

  // Store state
  const {
    searchQuery,
    priorityFilter,
    clientFilter,
    sortKey,
    sortDirection,
    isUserDropdownOpen,
    isPriorityDropdownOpen,
    isClientDropdownOpen,
    isLoadingTasks,
    actionMenuOpenId,
    undoStack,
    showUndo,
    userFilter,
    setFilteredTasks,
    setSearchQuery,
    setPriorityFilter,
    setClientFilter,
    setSortKey,
    setSortDirection,
    setIsUserDropdownOpen,
    setIsPriorityDropdownOpen,
    setIsClientDropdownOpen,
    setIsLoadingTasks,
    setIsLoadingClients,
    setIsLoadingUsers,
    setActionMenuOpenId,
    setUndoStack,
    setShowUndo,
    setUserFilter,
  } = useStore(
    tasksTableStore,
    useShallow(state => ({
      searchQuery: state.searchQuery,
      priorityFilter: state.priorityFilter,
      clientFilter: state.clientFilter,
      sortKey: state.sortKey,
      sortDirection: state.sortDirection,
      isUserDropdownOpen: state.isUserDropdownOpen,
      isPriorityDropdownOpen: state.isPriorityDropdownOpen,
      isClientDropdownOpen: state.isClientDropdownOpen,
      isLoadingTasks: state.isLoadingTasks,
      actionMenuOpenId: state.actionMenuOpenId,
      undoStack: state.undoStack,
      showUndo: state.showUndo,
      userFilter: state.userFilter,
      setFilteredTasks: state.setFilteredTasks,
      setSearchQuery: state.setSearchQuery,
      setPriorityFilter: state.setPriorityFilter,
      setClientFilter: state.setClientFilter,
      setSortKey: state.setSortKey,
      setSortDirection: state.setSortDirection,
      setIsUserDropdownOpen: state.setIsUserDropdownOpen,
      setIsPriorityDropdownOpen: state.setIsPriorityDropdownOpen,
      setIsClientDropdownOpen: state.setIsClientDropdownOpen,
      setIsLoadingTasks: state.setIsLoadingTasks,
      setIsLoadingClients: state.setIsLoadingClients,
      setIsLoadingUsers: state.setIsLoadingUsers,
      setActionMenuOpenId: state.setActionMenuOpenId,
      setUndoStack: state.setUndoStack,
      setShowUndo: state.setShowUndo,
      setUserFilter: state.setUserFilter,
    }))
  );

  // Refs para tracking de cambios
  useEffect(() => {
    const newIds = effectiveTasks.map(t => t.id).join(',');
    if (newIds !== effectiveTasksIdsRef.current) {
      effectiveTasksIdsRef.current = newIds;
      effectiveTasksRef.current = effectiveTasks;
      setFilteredTasks(effectiveTasks);
    }
  }, [effectiveTasks, setFilteredTasks]);

  // Setup de tasks con actualizaciones en tiempo real
  useEffect(() => {
    if (!user?.id || effectiveTasks.length > 0) return;

    console.log('[TasksTable] Using Zustand store - no duplicate onSnapshot');
    setIsLoadingTasks(false);
  }, [user?.id, effectiveTasks.length, setIsLoadingTasks]);

  // Setup de clients con actualizaciones en tiempo real
  useEffect(() => {
    if (!user?.id || effectiveClients.length > 0) return;

    console.log('[TasksTable] Setting up clients listener');
    setIsLoadingClients(true);

    const clientsQuery = query(collection(db, 'clients'));
    const unsubscribeClients = onSnapshot(
      clientsQuery,
      (snapshot) => {
        console.log('[TasksTable] Clients onSnapshot update:', snapshot.docs.length);
        setIsLoadingClients(false);
      },
      (error) => {
        console.error('[TasksTable] Error in clients onSnapshot:', error);
        setIsLoadingClients(false);
      }
    );

    return () => unsubscribeClients();
  }, [user?.id, effectiveClients.length, setIsLoadingClients]);

  // Setup de users
  useEffect(() => {
    if (!user?.id || effectiveUsers.length > 0) return;
    
    setIsLoadingUsers(true);
    
    const fetchUsers = async () => {
      try {
        const response = await fetch('/api/users');
        if (!response.ok) throw new Error(`Failed to fetch users: ${response.status}`);
        
        const clerkUsers = await response.json();
        console.log('[TasksTable] Users fetched:', clerkUsers.length);
        
        setIsLoadingUsers(false);
      } catch (error) {
        console.error('[TasksTable] Error fetching users:', error);
        setIsLoadingUsers(false);
      }
    };

    fetchUsers();
  }, [user?.id, effectiveUsers.length, setIsLoadingUsers]);

  // Helpers
  const getInvolvedUserIds = useCallback((task: Task) => {
    const ids = new Set<string>();
    if (task.CreatedBy) ids.add(task.CreatedBy);
    if (Array.isArray(task.AssignedTo)) task.AssignedTo.forEach((id) => ids.add(id));
    if (Array.isArray(task.LeadedBy)) task.LeadedBy.forEach((id) => ids.add(id));
    return Array.from(ids);
  }, []);

  // Event handlers  
  const handleSort = useCallback((key: string) => {
    if (key === sortKey) {
      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
    } else {
      setSortKey(key);
      setSortDirection(key === 'createdAt' ? 'desc' : 'asc');
    }
  }, [sortKey, setSortKey, sortDirection, setSortDirection]);

  const handleUserFilter = useCallback((id: string) => {
    const userDropdownTrigger = userDropdownRef.current?.querySelector(`.${styles.dropdownTrigger}`);
    if (userDropdownTrigger) {
      const filterIcon = userDropdownTrigger.querySelector('img');
      if (filterIcon) {
        gsap.to(filterIcon, {
          rotation: 360,
          scale: 1.2,
          duration: 0.3,
          ease: 'power2.out',
          yoyo: true,
          repeat: 1
        });
      }
    }
    
    setUserFilter(id);
    setIsUserDropdownOpen(false);
  }, [setUserFilter, setIsUserDropdownOpen]);

  const handlePrioritySelect = useCallback((priority: string, e: React.MouseEvent<HTMLDivElement>) => {
    const target = e.currentTarget;
    gsap.to(target, {
      scale: 0.95,
      opacity: 0.8,
      duration: 0.15,
      ease: 'power1.out',
      yoyo: true,
      repeat: 1,
    });
    
    setPriorityFilter(priority);
    setIsPriorityDropdownOpen(false);
  }, [setPriorityFilter, setIsPriorityDropdownOpen]);

  const handleClientSelect = useCallback((clientId: string, e: React.MouseEvent<HTMLDivElement>) => {
    const target = e.currentTarget;
    gsap.to(target, {
      scale: 0.95,
      opacity: 0.8,
      duration: 0.15,
      ease: 'power1.out',
      yoyo: true,
      repeat: 1,
    });
    
    setClientFilter(clientId);
    setIsClientDropdownOpen(false);
  }, [setClientFilter, setIsClientDropdownOpen]);

  // Función para deshacer
  const handleUndo = useCallback(async (undoItem: {task: Task, action: 'archive' | 'unarchive', timestamp: number}) => {
    if (!undoItem || !userId || !isAdmin) {
      console.error('Cannot undo: missing required data');
      return;
    }

    try {
      if (undoItem.action === 'archive') {
        await archiveTask(undoItem.task.id, userId, isAdmin, undoItem.task);
        setFilteredTasks(prev => 
          prev.map(t => 
            t.id === undoItem.task.id 
              ? { ...t, archived: false, archivedAt: undefined, archivedBy: undefined }
              : t
          )
        );
      }
      
      setUndoStack(undoStack.filter(item => item.timestamp !== undoItem.timestamp));
      setShowUndo(false);
      
      if (undoTimeoutRef.current) {
        clearTimeout(undoTimeoutRef.current);
      }
    } catch (error) {
      console.error('Error in undo process:', error);
    }
  }, [userId, isAdmin, setFilteredTasks, setUndoStack, setShowUndo, undoStack]);

  // Click handlers
  const handleTaskRowClick = useCallback(async (task: Task) => {
    await markAsViewed(task.id);
    onChatSidebarOpen(task);
  }, [markAsViewed, onChatSidebarOpen]);

  // Animation helper
  const animateClick = useCallback((element: HTMLElement) => {
    gsap.to(element, {
      scale: 0.95,
      opacity: 0.8,
      duration: 0.15,
      ease: 'power1.out',
      yoyo: true,
      repeat: 1,
    });
  }, []);

  // Animations
  useEffect(() => {
    if (actionMenuOpenId && actionMenuRef.current) {
      gsap.fromTo(
        actionMenuRef.current,
        { opacity: 0, y: -10, scale: 0.95 },
        { opacity: 1, y: 0, scale: 1, duration: 0.2, ease: 'power2.out' }
      );
    }
  }, [actionMenuOpenId]);

  useEffect(() => {
    if (isPriorityDropdownOpen && priorityDropdownRef.current) {
      const items = priorityDropdownRef.current.querySelector(`.${styles.dropdownItems}`);
      if (items) {
        gsap.fromTo(
          items,
          { opacity: 0, y: -10, scale: 0.95 },
          { opacity: 1, y: 0, scale: 1, duration: 0.2, ease: 'power2.out' }
        );
      }
    }
  }, [isPriorityDropdownOpen]);

  useEffect(() => {
    if (isClientDropdownOpen && clientDropdownRef.current) {
      const items = clientDropdownRef.current.querySelector(`.${styles.dropdownItems}`);
      if (items) {
        gsap.fromTo(
          items,
          { opacity: 0, y: -10, scale: 0.95 },
          { opacity: 1, y: 0, scale: 1, duration: 0.2, ease: 'power2.out' }
        );
      }
    }
  }, [isClientDropdownOpen]);

  useEffect(() => {
    if (isUserDropdownOpen && userDropdownRef.current) {
      const items = userDropdownRef.current.querySelector(`.${styles.dropdownItems}`);
      if (items) {
        gsap.fromTo(
          items,
          { opacity: 0, y: -10, scale: 0.95 },
          { opacity: 1, y: 0, scale: 1, duration: 0.2, ease: 'power2.out' }
        );
      }
    }
  }, [isUserDropdownOpen]);

  // Click outside handlers
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        actionMenuRef.current &&
        !actionMenuRef.current.contains(event.target as Node) &&
        !actionButtonRefs.current.get(actionMenuOpenId || '')?.contains(event.target as Node)
      ) {
        setActionMenuOpenId(null);
      }
      
      if (priorityDropdownRef.current && !priorityDropdownRef.current.contains(event.target as Node)) {
        setIsPriorityDropdownOpen(false);
      }
      
      if (clientDropdownRef.current && !clientDropdownRef.current.contains(event.target as Node)) {
        setIsClientDropdownOpen(false);
      }
      
      if (userDropdownRef.current && !userDropdownRef.current.contains(event.target as Node)) {
        setIsUserDropdownOpen(false);
      }
    };
    
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, [
    actionMenuOpenId,
    setActionMenuOpenId,
    setIsPriorityDropdownOpen,
    setIsClientDropdownOpen,
    setIsUserDropdownOpen
  ]);

  // Función para obtener las clases CSS de una fila de tarea
  const getRowClassName = useCallback(() => {
    return ''; // Removido el indicador de actualización de la fila completa
  }, []);

  const baseColumns = [
    {
      key: 'clientId',
      label: 'Cuenta',
      width: '20%',
      mobileVisible: false,
    },
    {
      key: 'name',
      label: 'Tarea',
      width: '60%', 
      mobileVisible: true,
    },
    {
      key: 'notificationDot',
      label: '',
      width: '20%',
      mobileVisible: true,
    },
    {
      key: 'assignedTo',
      label: 'Asignados',
      width: '20%',
      mobileVisible: false,
    },
    {
      key: 'status',
      label: 'Estado',
      width: '30%', 
      mobileVisible: false,
    },
    {
      key: 'priority',
      label: 'Prioridad',
      width: '10%',
      mobileVisible: false,
    },
    {
      key: 'action',
      label: 'Acciones',
      width: '10%',
      mobileVisible: false,
    },
  ];

  const columns = baseColumns.map((col) => {
    if (col.key === 'clientId') {
      return {
        ...col,
        render: (task: Task) => {
          const client = effectiveClients.find((c) => c.id === task.clientId);

          return client ? (
            <div className={styles.clientWrapper}>
              <Image
                style={{ borderRadius: '999px' }}
                src={client.imageUrl || '/empty-image.png'}
                alt={client.name || 'Client Image'}
                width={40}
                height={40}
                className={styles.clientImage}
                onError={(e) => {
                  e.currentTarget.src = '/empty-image.png';
                }}
              />
            </div>
          ) : 'Sin cuenta';
        },
      };
    }
    if (col.key === 'name') {
      return {
        ...col,
        render: (task: Task) => {
          return (
            <div className={styles.taskNameWrapper}>
              <span className={styles.taskName}>{task.name}</span>
            </div>
          );
        },
      };
    }
    if (col.key === 'notificationDot') {
      return {
        ...col,
        render: (task: Task) => {
          const updateCount = getUnreadCount(task);

          return (
            <div className={styles.notificationDotWrapper}>
              <NotificationDot count={updateCount} />
            </div>
          );
        },
      };
    }
    if (col.key === 'assignedTo') {
      return {
        ...col,
        render: (task: Task) => {

          return <AvatarGroup assignedUserIds={task.AssignedTo} leadedByUserIds={task.LeadedBy} users={effectiveUsers} currentUserId={userId} />;
        },
      };
    }
    if (col.key === 'status') {
      return {
        ...col,
        render: (task: Task) => {
          const normalizedStatus = normalizeStatus(task.status);
          let icon = '/timer.svg';
          if (normalizedStatus === 'En Proceso') icon = '/timer.svg';
          else if (normalizedStatus === 'Backlog') icon = '/circle-help.svg';
          else if (normalizedStatus === 'Por Iniciar') icon = '/circle.svg';
          else if (normalizedStatus === 'Cancelado') icon = '/circle-x.svg';
          else if (normalizedStatus === 'Por Finalizar') icon = '/circle-check.svg';
          else if (normalizedStatus === 'Finalizado') icon = '/check-check.svg';
          
          return (
            <div className={styles.statusWrapper}>
              <Image
                src={icon}
                alt={normalizedStatus}
                width={16}
                height={16}
                style={{ opacity: 0.7 }}
              />
              <span className={styles[`status-${normalizedStatus.replace(/\s/g, '-')}`]}>{normalizedStatus}</span>
            </div>
          );
        },
      };
    }
    if (col.key === 'priority') {
      return {
        ...col,
        render: (task: Task) => {

          return (
            <div className={styles.priorityWrapper}>
              <Image
                src={
                  task.priority === 'Alta'
                    ? '/arrow-up.svg'
                    : task.priority === 'Media'
                    ? '/arrow-right.svg'
                    : '/arrow-down.svg'
                }
                alt={task.priority}
                width={16}
                height={16}
              />
              <span className={styles[`priority-${task.priority}`]}>{task.priority}</span>
            </div>
          );
        },
      };
    }
    if (col.key === 'action') {
      return {
        ...col,
        render: (task: Task) => {
          if (isAdmin) {
            return (
              <ActionMenu
                task={task}
                userId={userId}
                onEdit={() => {
                  onEditTaskOpen(task.id);
                  setActionMenuOpenId(null);
                }}
                onDelete={() => {
                  onDeleteTaskOpen(task.id);
                  setActionMenuOpenId(null);
                }}
                onArchive={async () => {
                  try {
                    // Guardar en undo stack
                    const undoItem = {
                      task: { ...task },
                      action: 'archive' as const,
                      timestamp: Date.now()
                    };
                    setUndoStack([...undoStack, undoItem]);
                    setShowUndo(true);

                    // Limpiar timeout anterior
                    if (undoTimeoutRef.current) {
                      clearTimeout(undoTimeoutRef.current);
                    }

                    // Configurar timeout para limpiar undo
                    undoTimeoutRef.current = setTimeout(() => {
                      setShowUndo(false);
                      setUndoStack(undoStack.filter(item => item.timestamp !== undoItem.timestamp));
                    }, 3000);
                    
                    // Ejecutar la función de archivo
                    await archiveTask(task.id, userId, isAdmin, task);
                    setActionMenuOpenId(null);
                  } catch (error) {
                    console.error('Error archiving task:', error);
                  }
                }}
                animateClick={animateClick}
                actionMenuRef={actionMenuRef}
                actionButtonRef={(el) => {
                  if (el) {
                    actionButtonRefs.current.set(task.id, el);
                  } else {
                    actionButtonRefs.current.delete(task.id);
                  }
                }}
              />
            );
          }
          return null;
        },
      };
    }
    return col;
  });

  // Cleanup all table listeners when component unmounts
  useEffect(() => {
    return () => {
      console.log('[TasksTable] Cleaning up all table listeners on unmount');
      
      // Cleanup undo timeout
      if (undoTimeoutRef.current) {
        clearTimeout(undoTimeoutRef.current);
      }
    };
  }, []);

  // Memoized sorted tasks
  const sortedTasks = useMemo(() => {
    const filtered = effectiveTasks.filter((task) => {
      if (task.archived) return false;
      
      const canViewTask = isAdmin || getInvolvedUserIds(task).includes(userId);
      if (!canViewTask) return false;
      
      const matchesSearch = !searchQuery || task.name.toLowerCase().includes(searchQuery.toLowerCase());
      const matchesPriority = !priorityFilter || task.priority === priorityFilter;
      const matchesClient = !clientFilter || task.clientId === clientFilter;
      
      let matchesUser = true;
      if (userFilter === 'me') {
        matchesUser = getInvolvedUserIds(task).includes(userId);
      } else if (userFilter && userFilter !== 'me') {
        matchesUser = getInvolvedUserIds(task).includes(userFilter);
      }

      return matchesSearch && matchesPriority && matchesClient && matchesUser;
    });

    const sorted = [...filtered];
    
    if (sortKey === 'lastActivity') {
      sorted.sort((a, b) => {
        const activityA = getLastActivityTimestamp(a);
        const activityB = getLastActivityTimestamp(b);
        return sortDirection === 'asc' ? activityA - activityB : activityB - activityA;
      });
    } else if (sortKey === 'clientId') {
      sorted.sort((a, b) => {
        const clientA = effectiveClients.find((c) => c.id === a.clientId)?.name || '';
        const clientB = effectiveClients.find((c) => c.id === b.clientId)?.name || '';
        return sortDirection === 'asc'
          ? clientA.localeCompare(clientB)
          : clientB.localeCompare(clientA);
      });
    } else if (sortKey === 'status') {
      const statusOrder = ['Por Iniciar', 'Diseño', 'Desarrollo', 'En Proceso', 'Finalizado', 'Backlog', 'Cancelado'];
      sorted.sort((a, b) => {
        const indexA = statusOrder.indexOf(normalizeStatus(a.status));
        const indexB = statusOrder.indexOf(normalizeStatus(b.status));
        return sortDirection === 'asc' ? indexA - indexB : indexB - indexA;
      });
    } else if (sortKey === 'priority') {
      const priorityOrder = ['Alta', 'Media', 'Baja'];
      sorted.sort((a, b) => {
        const indexA = priorityOrder.indexOf(a.priority);
        const indexB = priorityOrder.indexOf(b.priority);
        return sortDirection === 'asc' ? indexA - indexB : indexB - indexA;
      });
    } else if (sortKey === 'createdAt') {
      sorted.sort((a, b) => {
        const dateA = new Date(a.createdAt).getTime();
        const dateB = new Date(b.createdAt).getTime();
        return sortDirection === 'asc' ? dateA - dateB : dateB - dateA;
      });
    } else {
      sorted.sort((a, b) =>
        sortDirection === 'asc'
          ? String(a[sortKey as keyof Task]).localeCompare(String(b[sortKey as keyof Task]))
          : String(b[sortKey as keyof Task]).localeCompare(String(a[sortKey as keyof Task]))
      );
    }

    return sorted;
  }, [
    effectiveTasks,
    searchQuery,
    priorityFilter,
    clientFilter,
    userFilter,
    sortKey,
    sortDirection,
    effectiveClients,
    userId,
    isAdmin,
    getInvolvedUserIds
  ]);

  // Loading state
  const shouldShowLoader = useMemo(() => {
    const hasExternalData = !!(externalTasks && externalClients && externalUsers);
    const hasAnyData = effectiveTasks.length > 0 || effectiveClients.length > 0 || effectiveUsers.length > 0;
    return !hasExternalData && !hasAnyData && isLoadingTasks;
  }, [
    externalTasks,
    externalClients,
    externalUsers,
    effectiveTasks.length,
    effectiveClients.length,
    effectiveUsers.length,
    isLoadingTasks
  ]);

  if (shouldShowLoader) {
    return (
      <div className={styles.container}>
        <style jsx>{`
          @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
          `}
        </style>
        <UserSwiper
          onOpenProfile={onOpenProfile}
          onMessageSidebarOpen={onMessageSidebarOpen}
          className={styles.hideOnMobile}
        />
        <div className={styles.header} style={{margin:'30px 0px'}}>
          <div className={styles.searchWrapper}>
            <div className={styles.searchInput} style={{ opacity: 0.5, pointerEvents: 'none' }}>
              <div style={{ width: '100%', height: '16px', background: '#f0f0f0', borderRadius: '4px' }} />
            </div>
          </div>
          <div className={styles.filtersWrapper}>
            <div className={styles.viewButton} style={{ opacity: 0.5, pointerEvents: 'none' }}>
              <div style={{ width: '20px', height: '20px', background: '#f0f0f0', borderRadius: '4px' }} />
              <div style={{ width: '80px', height: '16px', background: '#f0f0f0', borderRadius: '4px', marginLeft: '8px' }} />
            </div>
            <div className={styles.createButton} style={{ opacity: 0.5, pointerEvents: 'none' }}>
              <div style={{ width: '16px', height: '16px', background: '#f0f0f0', borderRadius: '4px' }} />
              <div style={{ width: '100px', height: '16px', background: '#f0f0f0', borderRadius: '4px', marginLeft: '8px' }} />
            </div>
          </div>
        </div>
        <SkeletonLoader type="tasks" rows={8} />
      </div>
    );
  }

  return (
    <div className={styles.container}>
      <style jsx>{`
        @keyframes pulse {
          0%, 100% { opacity: 1; }
          50% { opacity: 0.5; }
        `}
      </style>
      <UserSwiper
        onOpenProfile={onOpenProfile}
        onMessageSidebarOpen={onMessageSidebarOpen}
        className={styles.hideOnMobile}
      />
      <div className={styles.header} style={{margin:'30px 0px'}}>
        <div className={styles.searchWrapper}>
          <input
            type="text"
            placeholder="Buscar Tareas"
            value={searchQuery}
            onChange={(e) => {
              const newValue = e.target.value;
              setSearchQuery(newValue);
              
              // Animate search input when typing
              const searchInput = e.currentTarget;
              gsap.to(searchInput, {
                scale: 1.02,
                duration: 0.2,
                ease: 'power2.out',
                yoyo: true,
                repeat: 1
              });
              
              console.log('[TasksTable] Search query updated:', newValue);
            }}
            className={styles.searchInput}
            aria-label="Buscar tareas"
            disabled={shouldShowLoader}
            onKeyDown={(e) => {
              if (e.ctrlKey || e.metaKey) {
                switch (e.key.toLowerCase()) {
                  case 'a':
                    e.preventDefault();
                    e.currentTarget.select();
                    break;
                  case 'c':
                    e.preventDefault();
                    const targetC = e.currentTarget as HTMLInputElement;
                    if (targetC.selectionStart !== targetC.selectionEnd) {
                      const selectedText = searchQuery.substring(targetC.selectionStart || 0, targetC.selectionEnd || 0);
                      navigator.clipboard.writeText(selectedText).catch(() => {
                        const textArea = document.createElement('textarea');
                        textArea.value = selectedText;
                        document.body.appendChild(textArea);
                        textArea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textArea);
                      });
                    }
                    break;
                  case 'v':
                    e.preventDefault();
                    const targetV = e.currentTarget as HTMLInputElement;
                    navigator.clipboard.readText().then(text => {
                      if (typeof targetV.selectionStart === 'number' && typeof targetV.selectionEnd === 'number') {
                        const start = targetV.selectionStart;
                        const end = targetV.selectionEnd;
                        const newValue = searchQuery.substring(0, start) + text + searchQuery.substring(end);
                        setSearchQuery(newValue);
                        setTimeout(() => {
                          targetV.setSelectionRange(start + text.length, start + text.length);
                        }, 0);
                      } else {
                        setSearchQuery(searchQuery + text);
                      }
                    }).catch(() => {
                      document.execCommand('paste');
                    });
                    break;
                  case 'x':
                    e.preventDefault();
                    const targetX = e.currentTarget as HTMLInputElement;
                    if (targetX.selectionStart !== targetX.selectionEnd) {
                      const selectedText = searchQuery.substring(targetX.selectionStart || 0, targetX.selectionEnd || 0);
                      navigator.clipboard.writeText(selectedText).then(() => {
                        if (typeof targetX.selectionStart === 'number' && typeof targetX.selectionEnd === 'number') {
                          const start = targetX.selectionStart;
                          const end = targetX.selectionEnd;
                          const newValue = searchQuery.substring(0, start) + searchQuery.substring(end);
                          setSearchQuery(newValue);
                        } else {
                          setSearchQuery('');
                        }
                      }).catch(() => {
                        const textArea = document.createElement('textarea');
                        textArea.value = selectedText;
                        document.body.appendChild(textArea);
                        textArea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textArea);
                        if (typeof targetX.selectionStart === 'number' && typeof targetX.selectionEnd === 'number') {
                          const start = targetX.selectionStart;
                          const end = targetX.selectionEnd;
                          const newValue = searchQuery.substring(0, start) + searchQuery.substring(end);
                          setSearchQuery(newValue);
                        } else {
                          setSearchQuery('');
                        }
                      });
                    }
                    break;
                }
              }
            }}
          />
        </div>

        <div className={styles.filtersWrapper}>
          <div className={styles.buttonWithTooltip}>
            <button
              className={`${styles.viewButton} ${styles.hideOnMobile}`}
              onClick={(e) => {
                animateClick(e.currentTarget);
                onViewChange('kanban');
                console.log('[TasksTable] Switching to Kanban view');
              }}
            >
              <Image
                src="/kanban.svg"
                draggable="false"
                alt="kanban"
                width={20}
                height={20}
                style={{
                  marginLeft: '5px',
                  transition: 'transform 0.3s ease, filter 0.3s ease',
                  filter:
                    'drop-shadow(0 4px 8px rgba(0, 0, 0, 0.1)) drop-shadow(0 6px 20px rgba(0, 0, 0, 0.2))',
                }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.transform = 'scale(1.05)';
                  e.currentTarget.style.filter =
                    'drop-shadow(0 6px 12px rgba(0, 0, 0, 0.84)) drop-shadow(0 8px 25px rgba(0, 0, 0, 0.93))';
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.transform = 'scale(1)';
                  e.currentTarget.style.filter =
                    'drop-shadow(0 4px 8px rgba(0, 0, 0, 0.1)) drop-shadow(0 6px 20px rgba(0, 0, 0, 0.2))';
                }}
              />
            </button>
            <span className={styles.tooltip}>Vista Kanban</span>
          </div>
          <div className={styles.buttonWithTooltip}>
            <button
              className={styles.viewButton}
              onClick={(e) => {
                animateClick(e.currentTarget);
                onArchiveTableOpen();
                console.log('[TasksTable] Opening Archive Table');
              }}
            >
              <Image
                src="/archive.svg"
                draggable="false"
                alt="archivo"
                width={20}
                height={20}
                style={{
                  marginLeft: '5px',
                  transition: 'transform 0.3s ease, filter 0.3s ease',
                  filter:
                    'drop-shadow(0 4px 8px rgba(0, 0, 0, 0.1)) drop-shadow(0 6px 20px rgba(0, 0, 0, 0.2))',
                }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.transform = 'scale(1.05)';
                  e.currentTarget.style.filter =
                    'drop-shadow(0 6px 12px rgba(0, 0, 0, 0.84)) drop-shadow(0 8px 25px rgba(0, 0, 0, 0.93))';
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.transform = 'scale(1)';
                  e.currentTarget.style.filter =
                    'drop-shadow(0 4px 8px rgba(0, 0, 0, 0.1)) drop-shadow(0 6px 20px rgba(0, 0, 0, 0.2))';
                }}
              />
            </button>
            <span className={styles.tooltip}>Archivo</span>
          </div>
          <div className={styles.buttonWithTooltip}>
            <div className={styles.filter}>
              <div className={styles.dropdownContainer} ref={priorityDropdownRef}>
                <div
                  className={styles.dropdownTrigger}
                  onClick={(e) => {
                    animateClick(e.currentTarget);
                    setIsPriorityDropdownOpen(!isPriorityDropdownOpen);
                    if (!isPriorityDropdownOpen) {
                      setIsClientDropdownOpen(false);
                      setIsUserDropdownOpen(false);
                    }
                    console.log('[TasksTable] Priority dropdown toggled');
                  }}
                >
                  <Image className="filterIcon" src="/filter.svg" alt="Priority" width={12} height={12} />
                  <span>{priorityFilter || 'Prioridad'}</span>
                </div>
                {isPriorityDropdownOpen && (
                  <AnimatePresence>
                    <motion.div 
                      className={styles.dropdownItems}
                      initial={{ opacity: 0, y: -16 }}
                      animate={{ opacity: 1, y: 0 }}
                      exit={{ opacity: 0, y: -16 }}
                      transition={{ duration: 0.2, ease: "easeOut" }}
                    >
                      {['Alta', 'Media', 'Baja', ''].map((priority, index) => (
                        <motion.div
                          key={priority || 'all'}
                          className={styles.dropdownItem}
                          onClick={(e) => handlePrioritySelect(priority, e)}
                          initial={{ opacity: 0, y: -16 }}
                          animate={{ opacity: 1, y: 0 }}
                          transition={{ duration: 0.2, delay: index * 0.05 }}
                        >
                          {priority || 'Todos'}
                        </motion.div>
                      ))}
                    </motion.div>
                  </AnimatePresence>
                )}
              </div>
            </div>
            <span className={styles.tooltip}>Filtrar por Prioridad</span>
          </div>
          <div className={styles.buttonWithTooltip}>
            <div className={styles.filter}>
              <div className={styles.dropdownContainer} ref={clientDropdownRef}>
                <div
                  className={styles.dropdownTrigger}
                  onClick={(e) => {
                    animateClick(e.currentTarget);
                    setIsClientDropdownOpen(!isClientDropdownOpen);
                    if (!isClientDropdownOpen) {
                      setIsPriorityDropdownOpen(false);
                      setIsUserDropdownOpen(false);
                    }
                    console.log('[TasksTable] Client dropdown toggled');
                  }}
                >
                  <Image className="filterIcon" src="/filter.svg" alt="Client" width={12} height={12} />
                  <span>{effectiveClients.find((c) => c.id === clientFilter)?.name || 'Cuenta'}</span>
                </div>
                {isClientDropdownOpen && (
                  <AnimatePresence>
                    <motion.div 
                      className={styles.dropdownItems}
                      initial={{ opacity: 0, y: -16 }}
                      animate={{ opacity: 1, y: 0 }}
                      exit={{ opacity: 0, y: -16 }}
                      transition={{ duration: 0.2, ease: "easeOut" }}
                    >
                      {[{ id: '', name: 'Todos' }, ...effectiveClients].map((client, index) => (
                        <motion.div
                          key={client.id || 'all'}
                          className={styles.dropdownItem}
                          onClick={(e) => handleClientSelect(client.id, e)}
                          initial={{ opacity: 0, y: -16 }}
                          animate={{ opacity: 1, y: 0 }}
                          transition={{ duration: 0.2, delay: index * 0.05 }}
                        >
                          {client.name}
                        </motion.div>
                      ))}
                    </motion.div>
                  </AnimatePresence>
                )}
              </div>
            </div>
            <span className={styles.tooltip}>Filtrar por Cuenta</span>
          </div>

          {isAdmin && (
            <div className={styles.buttonWithTooltip}>
              <div className={styles.filter}>
                <div className={styles.dropdownContainer} ref={userDropdownRef}>
                  <div
                    className={styles.dropdownTrigger}
                    onClick={(e) => {
                      animateClick(e.currentTarget);
                      setIsUserDropdownOpen(!isUserDropdownOpen);
                      if (!isUserDropdownOpen) {
                        setIsPriorityDropdownOpen(false);
                        setIsClientDropdownOpen(false);
                      }
                      console.log('[TasksTable] User dropdown toggled');
                    }}
                  >
                    <Image className="filterIcon" src="/filter.svg" alt="User" width={12} height={12} />
                    <span>
                      {userFilter === '' 
                        ? 'Todos' 
                        : userFilter === 'me' 
                        ? 'Mis tareas' 
                        : effectiveUsers.find(u => u.id === userFilter)?.fullName || 'Usuario'}
                    </span>
                  </div>
                  {isUserDropdownOpen && (
                    <AnimatePresence>
                      <motion.div 
                        className={styles.dropdownItems}
                        initial={{ opacity: 0, y: -16 }}
                        animate={{ opacity: 1, y: 0 }}
                        exit={{ opacity: 0, y: -16 }}
                        transition={{ duration: 0.2, ease: "easeOut" }}
                      >
                        <motion.div
                          className={styles.dropdownItem}
                          style={{fontWeight: userFilter === '' ? 700 : 400}}
                          onClick={() => handleUserFilter('')}
                          initial={{ opacity: 0, y: -16 }}
                          animate={{ opacity: 1, y: 0 }}
                          transition={{ duration: 0.2, delay: 0 * 0.05 }}
                        >
                          Todos
                        </motion.div>
                        <motion.div
                          className={styles.dropdownItem}
                          style={{fontWeight: userFilter === 'me' ? 700 : 400}}
                          onClick={() => handleUserFilter('me')}
                          initial={{ opacity: 0, y: -16 }}
                          animate={{ opacity: 1, y: 0 }}
                          transition={{ duration: 0.2, delay: 1 * 0.05 }}
                        >
                          Mis tareas
                        </motion.div>
                        {effectiveUsers
                          .filter((u) => u.id !== userId)
                          .map((u, index) => (
                            <motion.div
                              key={u.id}
                              className={styles.dropdownItem}
                              style={{fontWeight: userFilter === u.id ? 700 : 400}}
                              onClick={() => handleUserFilter(u.id)}
                              initial={{ opacity: 0, y: -16 }}
                              animate={{ opacity: 1, y: 0 }}
                              transition={{ duration: 0.2, delay: (index + 2) * 0.05 }}
                            >
                              {u.fullName}
                            </motion.div>
                          ))}
                      </motion.div>
                    </AnimatePresence>
                  )}
                </div>
              </div>
              <span className={styles.tooltip}>Filtrar por Usuario</span>
            </div>
          )}

          
          <div className={styles.buttonWithTooltip}>
            <button
              className={styles.createButton}
              onClick={(e) => {
                animateClick(e.currentTarget);
                onNewTaskOpen();
                console.log('[TasksTable] New task creation triggered');
              }}
            >
              <Image src="/square-dashed-mouse-pointer.svg" alt="New Task" width={16} height={16} />
              <span className={styles.createButtonText}>Crear Tarea</span>
            </button>
            <span className={styles.tooltip}>Crear Nueva Tarea</span>
          </div>
        </div>
      </div>

      <Table
        key={`tasks-table-${effectiveTasksIdsRef.current}`}
        data={sortedTasks}
        columns={columns}
        itemsPerPage={10}
        sortKey={sortKey}
        sortDirection={sortDirection}
        onSort={handleSort}
        onRowClick={(task: Task) => {
          handleTaskRowClick(task);
        }}
        getRowClassName={getRowClassName}
        emptyStateType="tasks"
      />
      
      {/* Undo Notification */}
      <AnimatePresence>
        {showUndo && undoStack.length > 0 && (
          <motion.div
            initial={{ opacity: 0, y: 50, scale: 0.9 }}
            animate={{ opacity: 1, y: 0, scale: 1 }}
            exit={{ opacity: 0, y: 50, scale: 0.9 }}
            transition={{ duration: 0.3, ease: "easeOut" }}
            className={styles.undoNotification}
            style={{
              position: 'fixed',
              bottom: '20px',
              right: '20px',
              backgroundColor: '#10b981',
              color: 'white',
              padding: '16px 20px',
              borderRadius: '12px',
              boxShadow: '0 8px 32px rgba(0, 0, 0, 0.2)',
              zIndex: 9999,
              display: 'flex',
              alignItems: 'center',
              gap: '16px',
              fontSize: '14px',
              fontWeight: 500,
              minWidth: '280px',
              backdropFilter: 'blur(10px)',
              border: '1px solid rgba(255, 255, 255, 0.1)'
            }}
          >
            <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
              <div style={{
                width: '8px',
                height: '8px',
                backgroundColor: 'white',
                borderRadius: '50%',
                animation: 'pulse 2s infinite'
              }} />
              <span>Tarea archivada</span>
            </div>
            <button
              onClick={() => {
                handleUndo(undoStack[undoStack.length - 1]);
              }}
              style={{
                backgroundColor: 'rgba(255, 255, 255, 0.2)',
                border: 'none',
                color: 'white',
                padding: '8px 16px',
                borderRadius: '8px',
                cursor: 'pointer',
                fontSize: '13px',
                fontWeight: 600,
                transition: 'all 0.2s ease',
                whiteSpace: 'nowrap'
              }}
              onMouseEnter={(e) => {
                e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
                e.currentTarget.style.transform = 'scale(1.05)';
              }}
              onMouseLeave={(e) => {
                e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
                e.currentTarget.style.transform = 'scale(1)';
              }}
            >
              Deshacer
            </button>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
});

TasksTable.displayName = 'TasksTable';

export default TasksTable;